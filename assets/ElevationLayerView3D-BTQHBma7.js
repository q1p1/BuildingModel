import{e as u,t as m,q as f,w as d,x as p,z as g,r as n,m as h,a as w}from"./index-CBbuaskE.js";import{s as v,a as $}from"./LercDecoder-XkexGlXL.js";import{l as D}from"./LayerView3D-BNwx6bZK.js";import{p as T}from"./TiledLayerView3D-DF1DjUpK.js";import{y as b}from"./LayerView-WBKgAOvw.js";import"./WorkerHandle-DKLVHPVg.js";let i=class extends T(D(b)){constructor(){super(...arguments),this.type="elevation-3d"}get tileInfo(){return this.layer.tileInfo}initialize(){var r,o,c;const e=this.view,t=(r=e.map)==null?void 0:r.allLayers,s=t&&t.includes(this.layer),a=(c=(o=e.map)==null?void 0:o.ground)==null?void 0:c.layers,l=a&&a.includes(this.layer);if(s&&!l){const y=new u("layerview:elevation-layer-only",`3D elevation layer '${this.layer.id}' can only be added to layers in map.ground`);this.addResolvingPromise(Promise.reject(y))}this._lercDecoder=v(e.resourceController),this._addTilingSchemeMatchPromise()}destroy(){this._lercDecoder=m(this._lercDecoder)}async fetchTile(e,t){const s=this.layer;if(f(s)){const o=await s.fetchTile(e[0],e[1],e[2],{noDataValue:d,signal:t.signal});return p(t)?void g.getLogger(this).warnOnce("A call to fetchTile resolved even though the request was aborted. fetchTile should not resolve if options.signal.aborted is true."):o}const a=this.getTileUrl(e),l=await t.requester.request(a,"binary",t),r=await this._lercDecoder.decode(l,{noDataValue:d},t.signal);if(r)return new $(r);throw new Error("LERC decoding failed")}};n([h()],i.prototype,"layer",void 0),n([h()],i.prototype,"tileInfo",null),i=n([w("esri.views.3d.layers.ElevationLayerView3D")],i);const P=i;export{P as default};
