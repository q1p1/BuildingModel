import{wm as $,wn as E,wo as b,wp as D,wq as y,wr as O,ws as S,ba as n,wt as g,wu as x,wv as A,ww as C,wx as I,wy as N,wz as R,_ as F,wA as T,wB as V,wC as L,wD as M,wE as j,wF as B,wG as z,wH as U,wI as W,wJ as H,wK as k,wL as q,wM as G,r as a,wN as o,ki as v,wO as Q,mv as J,wP as K,kT as w,wQ as _,wR as f,wS as X,wT as Y,wU as Z,w1 as ee,wV as te,wW as se,mx as ie,wX as re}from"./index-HdUx8m3z.js";import{f as ae}from"./DefaultLayouts-s3ykROnF.js";import{e as oe}from"./TriangleMaterial-BaVzgn1f.js";function P(s){const e=new $,{vertex:t,fragment:i}=e;return E(t,s),e.include(b,s),e.include(D,s),e.include(y,s),e.include(O,s),e.include(S,s),e.attributes.add(n.POSITION,"vec3"),e.attributes.add(n.UV0,"vec2"),s.perspectiveInterpolation&&e.attributes.add(n.PERSPECTIVEDIVIDE,"float"),e.varyings.add("vpos","vec3"),s.terrainDepthTest&&e.varyings.add("depth","float"),t.main.add(g`
    vpos = position;
    ${s.terrainDepthTest?"depth = (view * vec4(vpos, 1.0)).z;":""}
    vTexCoord = uv0;
    gl_Position = transformPosition(proj, view, vpos);
    ${s.perspectiveInterpolation?"gl_Position *= perspectiveDivide;":""}`),i.uniforms.add(new x("tex",l=>l.texture),new A("opacity",l=>l.opacity)),e.varyings.add("vTexCoord","vec2"),i.include(C),i.main.add(g`
    discardBySlice(vpos);
    ${s.terrainDepthTest?"terrainDepthTest(depth);":""}
    ${s.output===I.ObjectAndLayerIdColor?`fragColor = vec4(0, 0, 0, 1);
           return;`:""}
    vec4 finalColor = texture(tex, vTexCoord) * opacity;
    outputColorHighlightOID(finalColor, vpos);`),e}const ne=Object.freeze(Object.defineProperty({__proto__:null,build:P},Symbol.toStringTag,{value:"Module"}));class le extends N{constructor(e,t,i){super(e,t,new R(ne,()=>F(()=>Promise.resolve().then(()=>de),void 0)),i,m)}_getPipelineState(e,t){const{oitPass:i,output:l,hasOccludees:u,enableOffset:d,cullFace:c}=e,p=i===T.NONE,h=i===T.FrontFace;return V({blending:l===I.Color?p?L:M(i):null,culling:j(c),depthTest:{func:B(i)},depthWrite:z(e),drawBuffers:U(i,l),colorWrite:W,stencilWrite:u?H:null,stencilTest:u?t?k:q:null,polygonOffset:p||h?null:G(d)})}initializePipeline(e){return this._occludeePipeline=this._getPipelineState(e,!0),this._getPipelineState(e,!1)}getPipeline(e){return e?this._occludeePipeline:super.getPipeline()}}const m=new Map([[n.POSITION,0],[n.UV0,2],[n.PERSPECTIVEDIVIDE,3]]);class r extends Q{constructor(){super(...arguments),this.cullFace=v.None,this.hasSlicePlane=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.perspectiveInterpolation=!0,this.textureCoordinateType=J.None,this.emissionSource=K.None,this.discardInvisibleFragments=!0,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1}}a([o({count:v.COUNT})],r.prototype,"cullFace",void 0),a([o()],r.prototype,"hasSlicePlane",void 0),a([o()],r.prototype,"enableOffset",void 0),a([o()],r.prototype,"writeDepth",void 0),a([o()],r.prototype,"hasOccludees",void 0),a([o()],r.prototype,"terrainDepthTest",void 0),a([o()],r.prototype,"cullAboveTerrain",void 0),a([o()],r.prototype,"perspectiveInterpolation",void 0);let ve=class extends oe{constructor(e){super(e,ue),this._configuration=new r,this.vertexAttributeLocations=m,this.supportsEdges=!0,this.produces=new Map([[w.OPAQUE_MATERIAL,t=>_(t)],[w.TRANSPARENT_MATERIAL,t=>f(t)&&this.parameters.writeDepth],[w.TRANSPARENT_MATERIAL_WITHOUT_DEPTH,t=>f(t)&&!this.parameters.writeDepth],[w.DRAPED_MATERIAL,t=>f(t)||_(t)]])}getConfiguration(e,t){return this._configuration.output=e,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=t.hasOccludees,this._configuration.oitPass=t.oitPass,this._configuration.enableOffset=t.camera.relativeElevation<X,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration.perspectiveInterpolation=this.parameters.perspectiveInterpolation,this._configuration}get visible(){return!0}createGLMaterial(e){return new pe(e)}createBufferWriter(){const e=ae.clone();return this.parameters.perspectiveInterpolation&&e.f32(n.PERSPECTIVEDIVIDE),new ce(e)}};class pe extends Y{constructor(e){super({...e,...e.material.parameters})}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.acquireTechnique(le,e)}}class ce extends Z{write(e,t,i,l,u,d){for(const c of this.vertexBufferLayout.fields.keys()){const p=i.get(c);if(p)if(c===n.PERSPECTIVEDIVIDE){ee(p.size===1);const h=u.getField(c,te);h&&se(p,h,d)}else ie(c,p,e,t,u,d)}}}class ue extends re{constructor(){super(...arguments),this.writeDepth=!0,this.hasSlicePlane=!1,this.cullFace=v.None,this.opacity=1,this.textureId=null,this.initTextureTransparent=!0,this.perspectiveInterpolation=!1}}const de=Object.freeze(Object.defineProperty({__proto__:null,build:P},Symbol.toStringTag,{value:"Module"}));export{ve as I};
