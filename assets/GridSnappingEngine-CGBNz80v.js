import{f6 as D,cV as U,av as W,as as j,gN as E,at as I,b as O,e6 as z,mf as F,cU as V,z as k,gC as B,mg as H,r as l,m as p,a as K,mh as L}from"./index-CfghLkOD.js";import{M as N,P as T}from"./normalizeUtils-B_K5T9pJ.js";import{y as _,R as A}from"./viewUtils-CdHzSE74.js";import{k as S,m as J,l as X,q as Q,t as Z}from"./SnappingManagerPool-DS_QRb09.js";import"./normalizeUtilsCommon-BHZVZHaX.js";import"./keybindings-DUlhBE4N.js";import"./utils-CPdV0Sb_.js";import"./geometry2dUtils-CbwnEJri.js";const ee=50,te=5;function re(e,n){return Math.log(e)/Math.log(n)}function ne(e,n,r){const t=e===1?10:e;return t**(r?Math.round(re(ee/n,t)):0)}function ie(e){const{isGeographic:n,isWebMercator:r}=e;return!n&&!r}function se(e,n,r){const t=typeof e=="number"?null:e,i=r??(t==null?void 0:t.spatialReference);if(i==null||!D(i)||ie(i))return U(i);let s=(t==null?void 0:t.x)??e,o=(t==null?void 0:t.y)??n;const u=1/Math.sqrt(2);let d=s+u,f=o+u;const{isWebMercator:h,isGeographic:R}=i;let w=R&&!_(i)?W.WGS84:i;if(h){let c=new j({x:s,y:o,spatialReference:i});E(c,!0,c),s=c.x,o=c.y,c=new j({x:d,y:f,spatialReference:i}),E(c,!0,c),d=c.x,f=c.y,w=W.WGS84}const M=new I({paths:[[[s,o],[d,f]]],spatialReference:w}),x=N(M,10);let g;try{[g]=A([x],"meters")}catch{return U(i)}return g}let a=class extends O{constructor(e){super(e),this.options=null}destroy(){this._set("options",null)}get grid(){return this.view.grid}get effectiveViewRotation(){var e;return(e=this.grid)!=null&&e.rotateWithMap?0:z(this.view.rotation??0)}get gridRotation(){var e;return z(((e=this.grid)==null?void 0:e.rotation)??0)}get gridCenter(){var r;const{spatialReference:e,grid:n}=this;if(!n||!e||!F(n.center.spatialReference,e))return null;try{const t=V(n.center,e),i=e.isWrappable&&((r=this.view)==null?void 0:r.center)!=null?T(t.x,this.view.center.x,e):t.x;return S(i,t.y,t.z)}catch(t){return k.getLogger(this).errorOnce("Grid Snapping - Failed to project grid center.",t),null}}get offsetScaleFactor(){const{pixelsPerStride:e,grid:n}=this;if(!n||!e)return 1;const{majorLineInterval:r,dynamicScaling:t}=n;return r<1?null:ne(r,e,t)}get spatialReference(){return this.view.spatialReference}get gridMetersPerStride(){const{grid:e}=this;return e?B(e.spacing,e.units,"meters"):null}get viewMetersPerPixel(){const{viewMetersPerSRUnit:e}=this;return e==null?null:e*H(this.view.scale,this.view.spatialReference)}get viewMetersPerSRUnit(){const{spatialReference:e}=this.view;return this.gridCenter?se(this.gridCenter[0],this.gridCenter[1],e):null}get pixelsPerStride(){const{gridMetersPerStride:e,viewMetersPerPixel:n}=this;return n&&e?e/n:null}get updating(){return this.grid!=null&&this.spatialReference!=null&&this.viewMetersPerSRUnit==null}async fetchCandidates(e,n,r){var u;const{options:t,view:i}=this;if(!(t!=null&&t.effectiveGridEnabled)||!i.grid||(u=r.feature)!=null&&u.attributes&&J in r.feature.attributes)return[];const s=r.coordinateHelper.arrayToPoint(e),o=t.distance*(r.pointer==="touch"?t.touchSensitivityMultiplier:1);return this.fetchCandidatesSync(s,o)}fetchCandidatesSync(e,n){const r=[],{grid:t,effectiveViewRotation:i,gridRotation:s,gridCenter:o,viewMetersPerPixel:u,viewMetersPerSRUnit:d,offsetScaleFactor:f,spatialReference:h,gridMetersPerStride:R,pixelsPerStride:w}=this;if(!(t&&u&&d&&o&&h&&f&&R&&w)||!t.dynamicScaling&&w<te||!F(e.spatialReference,h))return r;const M=V(e,h),x=S(M.x,M.y,M.z),g=v(x,-s,o,-i),c=R/d*f,y=oe(g,c,o),{shouldSnapX:P,shouldSnapY:m}=ae(y,g,n,u,d);if(!P&&!m)return[];const q=S((P?y:g)[0],(m?y:g)[1]),$=v(q,s,o,i),G=v(y,s,o,i);if(m){const b=Y(y,g,c,"y"),C=v(b,s,o,i);r.push(new X({lineStart:G,lineEnd:C,targetPoint:$,isDraped:!1}))}if(P){const b=Y(y,g,c,"x"),C=v(b,s,o,i);r.push(new X({lineStart:G,lineEnd:C,targetPoint:$,isDraped:!1}))}return P&&m&&r.push(new Q($,r[0],r[1],!1)),r}};l([p({constructOnly:!0})],a.prototype,"view",void 0),l([p()],a.prototype,"options",void 0),l([p()],a.prototype,"grid",null),l([p()],a.prototype,"effectiveViewRotation",null),l([p()],a.prototype,"gridRotation",null),l([p()],a.prototype,"gridCenter",null),l([p()],a.prototype,"offsetScaleFactor",null),l([p()],a.prototype,"spatialReference",null),l([p()],a.prototype,"gridMetersPerStride",null),l([p()],a.prototype,"viewMetersPerPixel",null),l([p()],a.prototype,"viewMetersPerSRUnit",null),l([p()],a.prototype,"pixelsPerStride",null),l([p()],a.prototype,"updating",null),a=l([K("esri.views.interactive.snapping.GridSnappingEngine")],a);const v=(e,n,r,t)=>{const i=Z(e[0],e[1],e[2]);return L(i,L(i,i,r,n),r,t)},oe=(e,n,r)=>{const t=(e[0]-r[0])/n,i=(e[1]-r[1])/n,s=Math.trunc(t),o=Math.trunc(i),u=Math.round(t%1),d=Math.round(i%1),f=r[0]+(s+u)*n,h=r[1]+(o+d)*n;return S(f,h)},ae=(e,n,r,t,i)=>{if(t<=0)return{shouldSnapX:!1,shouldSnapY:!1};const s=(e[0]-n[0])/t,o=(e[1]-n[1])/t;return{shouldSnapX:Math.abs(s*i)<r,shouldSnapY:Math.abs(o*i)<r}},Y=(e,n,r,t)=>{if(t==="y"){const s=n[0]>e[0]?1:-1;return S(e[0]+r*s,e[1])}const i=n[1]>e[1]?1:-1;return S(e[0],e[1]+r*i)};export{a as GridSnappingEngine};
